// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: merchant_business_information.sql

package db

import (
	"context"
	"database/sql"
)

const createMerchantBusinessInformation = `-- name: CreateMerchantBusinessInformation :one
INSERT INTO merchant_business_information (
    merchant_id,
    business_type,
    tax_id,
    established_year,
    number_of_employees,
    website_url
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING merchant_business_info_id, merchant_id, business_type, tax_id, established_year, number_of_employees, website_url, created_at, updated_at, deleted_at
`

type CreateMerchantBusinessInformationParams struct {
	MerchantID        int32          `json:"merchant_id"`
	BusinessType      sql.NullString `json:"business_type"`
	TaxID             sql.NullString `json:"tax_id"`
	EstablishedYear   sql.NullInt32  `json:"established_year"`
	NumberOfEmployees sql.NullInt32  `json:"number_of_employees"`
	WebsiteUrl        sql.NullString `json:"website_url"`
}

// CreateMerchantBusinessInformation: Inserts a new business info record
// Purpose: Register extended business info for a merchant
// Parameters:
//
//	$1: merchant_id
//	$2: business_type
//	$3: tax_id
//	$4: established_year
//	$5: number_of_employees
//	$6: website_url
//
// Returns: The newly created business info record
// Business Logic:
//   - Sets created_at timestamp automatically
//   - Validates all required fields
func (q *Queries) CreateMerchantBusinessInformation(ctx context.Context, arg CreateMerchantBusinessInformationParams) (*MerchantBusinessInformation, error) {
	row := q.db.QueryRowContext(ctx, createMerchantBusinessInformation,
		arg.MerchantID,
		arg.BusinessType,
		arg.TaxID,
		arg.EstablishedYear,
		arg.NumberOfEmployees,
		arg.WebsiteUrl,
	)
	var i MerchantBusinessInformation
	err := row.Scan(
		&i.MerchantBusinessInfoID,
		&i.MerchantID,
		&i.BusinessType,
		&i.TaxID,
		&i.EstablishedYear,
		&i.NumberOfEmployees,
		&i.WebsiteUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentMerchantBusinessInformation = `-- name: DeleteAllPermanentMerchantBusinessInformation :exec
DELETE FROM merchant_business_information
WHERE deleted_at IS NOT NULL
`

// DeleteAllPermanentMerchantBusinessInformation: Hard-deletes all trashed records
// Purpose: Clean up all soft-deleted business info entries
// Business Logic:
//   - Irreversible bulk delete
//   - Used during database cleanup/maintenance
func (q *Queries) DeleteAllPermanentMerchantBusinessInformation(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentMerchantBusinessInformation)
	return err
}

const deleteMerchantBusinessInformationPermanently = `-- name: DeleteMerchantBusinessInformationPermanently :exec
DELETE FROM merchant_business_information
WHERE merchant_business_info_id = $1
  AND deleted_at IS NOT NULL
`

// DeleteMerchantBusinessInformationPermanently: Hard-deletes a single record
// Purpose: Completely remove soft-deleted business info
// Parameters:
//
//	$1: merchant_business_info_id
//
// Business Logic:
//   - Irreversible operation
//   - Only affects already soft-deleted records
func (q *Queries) DeleteMerchantBusinessInformationPermanently(ctx context.Context, merchantBusinessInfoID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMerchantBusinessInformationPermanently, merchantBusinessInfoID)
	return err
}

const getMerchantBusinessInformation = `-- name: GetMerchantBusinessInformation :one
SELECT merchant_business_info_id, merchant_id, business_type, tax_id, established_year, number_of_employees, website_url, created_at, updated_at, deleted_at
FROM merchant_business_information
WHERE merchant_business_info_id = $1
AND deleted_at IS NULL
`

// GetMerchantBusinessInformation: Retrieves a single business information record that is not soft-deleted
// Parameters:
//
//	$1: merchant_business_info_id - ID of the business info
//
// Business Logic:
//   - Returns the merchant business information where deleted_at IS NULL
//
// Returns: A single merchant_business_information record
func (q *Queries) GetMerchantBusinessInformation(ctx context.Context, merchantBusinessInfoID int32) (*MerchantBusinessInformation, error) {
	row := q.db.QueryRowContext(ctx, getMerchantBusinessInformation, merchantBusinessInfoID)
	var i MerchantBusinessInformation
	err := row.Scan(
		&i.MerchantBusinessInfoID,
		&i.MerchantID,
		&i.BusinessType,
		&i.TaxID,
		&i.EstablishedYear,
		&i.NumberOfEmployees,
		&i.WebsiteUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getMerchantsBusinessInformation = `-- name: GetMerchantsBusinessInformation :many
SELECT 
    mbi.merchant_business_info_id, mbi.merchant_id, mbi.business_type, mbi.tax_id, mbi.established_year, mbi.number_of_employees, mbi.website_url, mbi.created_at, mbi.updated_at, mbi.deleted_at,
    m.name AS merchant_name,
    COUNT(*) OVER() AS total_count
FROM merchant_business_information mbi
JOIN merchants m ON mbi.merchant_id = m.merchant_id
WHERE LOWER(m.name) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetMerchantsBusinessInformationParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetMerchantsBusinessInformationRow struct {
	MerchantBusinessInfoID int32          `json:"merchant_business_info_id"`
	MerchantID             int32          `json:"merchant_id"`
	BusinessType           sql.NullString `json:"business_type"`
	TaxID                  sql.NullString `json:"tax_id"`
	EstablishedYear        sql.NullInt32  `json:"established_year"`
	NumberOfEmployees      sql.NullInt32  `json:"number_of_employees"`
	WebsiteUrl             sql.NullString `json:"website_url"`
	CreatedAt              sql.NullTime   `json:"created_at"`
	UpdatedAt              sql.NullTime   `json:"updated_at"`
	DeletedAt              sql.NullTime   `json:"deleted_at"`
	MerchantName           string         `json:"merchant_name"`
	TotalCount             int64          `json:"total_count"`
}

// GetMerchantsBusinessInformation: Retrieves all business info records with pagination and optional search
// Parameters:
//
//	$1: search - Keyword to filter merchant_name (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Fetches all merchant business information regardless of merchant status (active or deleted)
//   - Supports case-insensitive partial search by merchant name
//   - Applies pagination using limit and offset
//
// Returns: All business info records matching the search, with total_count for pagination
func (q *Queries) GetMerchantsBusinessInformation(ctx context.Context, arg GetMerchantsBusinessInformationParams) ([]*GetMerchantsBusinessInformationRow, error) {
	rows, err := q.db.QueryContext(ctx, getMerchantsBusinessInformation, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMerchantsBusinessInformationRow
	for rows.Next() {
		var i GetMerchantsBusinessInformationRow
		if err := rows.Scan(
			&i.MerchantBusinessInfoID,
			&i.MerchantID,
			&i.BusinessType,
			&i.TaxID,
			&i.EstablishedYear,
			&i.NumberOfEmployees,
			&i.WebsiteUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.MerchantName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantsBusinessInformationActive = `-- name: GetMerchantsBusinessInformationActive :many
SELECT 
    mbi.merchant_business_info_id, mbi.merchant_id, mbi.business_type, mbi.tax_id, mbi.established_year, mbi.number_of_employees, mbi.website_url, mbi.created_at, mbi.updated_at, mbi.deleted_at,
    m.name AS merchant_name,
    COUNT(*) OVER() AS total_count
FROM merchant_business_information mbi
JOIN merchants m ON mbi.merchant_id = m.merchant_id
WHERE m.deleted_at IS NULL
  AND LOWER(m.name) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetMerchantsBusinessInformationActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetMerchantsBusinessInformationActiveRow struct {
	MerchantBusinessInfoID int32          `json:"merchant_business_info_id"`
	MerchantID             int32          `json:"merchant_id"`
	BusinessType           sql.NullString `json:"business_type"`
	TaxID                  sql.NullString `json:"tax_id"`
	EstablishedYear        sql.NullInt32  `json:"established_year"`
	NumberOfEmployees      sql.NullInt32  `json:"number_of_employees"`
	WebsiteUrl             sql.NullString `json:"website_url"`
	CreatedAt              sql.NullTime   `json:"created_at"`
	UpdatedAt              sql.NullTime   `json:"updated_at"`
	DeletedAt              sql.NullTime   `json:"deleted_at"`
	MerchantName           string         `json:"merchant_name"`
	TotalCount             int64          `json:"total_count"`
}

// GetMerchantsBusinessInformationActive: Retrieves business info for active (non-deleted) merchants with pagination and optional search
// Parameters:
//
//	$1: search - Keyword to filter merchant_name (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Fetches merchant business information for only active merchants (deleted_at IS NULL)
//   - Supports case-insensitive partial search by merchant name
//   - Applies pagination using limit and offset
//
// Returns: Business info records for active merchants matching the search, with total_count
func (q *Queries) GetMerchantsBusinessInformationActive(ctx context.Context, arg GetMerchantsBusinessInformationActiveParams) ([]*GetMerchantsBusinessInformationActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getMerchantsBusinessInformationActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMerchantsBusinessInformationActiveRow
	for rows.Next() {
		var i GetMerchantsBusinessInformationActiveRow
		if err := rows.Scan(
			&i.MerchantBusinessInfoID,
			&i.MerchantID,
			&i.BusinessType,
			&i.TaxID,
			&i.EstablishedYear,
			&i.NumberOfEmployees,
			&i.WebsiteUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.MerchantName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantsBusinessInformationTrashed = `-- name: GetMerchantsBusinessInformationTrashed :many
SELECT 
    mbi.merchant_business_info_id, mbi.merchant_id, mbi.business_type, mbi.tax_id, mbi.established_year, mbi.number_of_employees, mbi.website_url, mbi.created_at, mbi.updated_at, mbi.deleted_at,
    m.name AS merchant_name,
    COUNT(*) OVER() AS total_count
FROM merchant_business_information mbi
JOIN merchants m ON mbi.merchant_id = m.merchant_id
WHERE m.deleted_at IS NOT NULL
  AND LOWER(m.name) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetMerchantsBusinessInformationTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetMerchantsBusinessInformationTrashedRow struct {
	MerchantBusinessInfoID int32          `json:"merchant_business_info_id"`
	MerchantID             int32          `json:"merchant_id"`
	BusinessType           sql.NullString `json:"business_type"`
	TaxID                  sql.NullString `json:"tax_id"`
	EstablishedYear        sql.NullInt32  `json:"established_year"`
	NumberOfEmployees      sql.NullInt32  `json:"number_of_employees"`
	WebsiteUrl             sql.NullString `json:"website_url"`
	CreatedAt              sql.NullTime   `json:"created_at"`
	UpdatedAt              sql.NullTime   `json:"updated_at"`
	DeletedAt              sql.NullTime   `json:"deleted_at"`
	MerchantName           string         `json:"merchant_name"`
	TotalCount             int64          `json:"total_count"`
}

// GetMerchantBusinessInformationTrashed: Retrieves business info for deleted merchants with pagination and optional search
// Parameters:
//
//	$1: search - Keyword to filter merchant_name (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Fetches merchant business information for only deleted merchants (deleted_at IS NOT NULL)
//   - Supports case-insensitive partial search by merchant name
//   - Applies pagination using limit and offset
//
// Returns: Business info records for deleted merchants matching the search, with total_count
func (q *Queries) GetMerchantsBusinessInformationTrashed(ctx context.Context, arg GetMerchantsBusinessInformationTrashedParams) ([]*GetMerchantsBusinessInformationTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getMerchantsBusinessInformationTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMerchantsBusinessInformationTrashedRow
	for rows.Next() {
		var i GetMerchantsBusinessInformationTrashedRow
		if err := rows.Scan(
			&i.MerchantBusinessInfoID,
			&i.MerchantID,
			&i.BusinessType,
			&i.TaxID,
			&i.EstablishedYear,
			&i.NumberOfEmployees,
			&i.WebsiteUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.MerchantName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllMerchantBusinessInformation = `-- name: RestoreAllMerchantBusinessInformation :exec
UPDATE merchant_business_information
SET deleted_at = NULL
WHERE deleted_at IS NOT NULL
`

// RestoreAllMerchantBusinessInformation: Restores all soft-deleted records
// Purpose: Bulk recovery operation
// Business Logic:
//   - Clears deleted_at on all trashed records
//   - Useful during data recovery or admin resets
func (q *Queries) RestoreAllMerchantBusinessInformation(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllMerchantBusinessInformation)
	return err
}

const restoreMerchantBusinessInformation = `-- name: RestoreMerchantBusinessInformation :one
UPDATE merchant_business_information
SET deleted_at = NULL
WHERE merchant_business_info_id = $1
  AND deleted_at IS NOT NULL
RETURNING merchant_business_info_id, merchant_id, business_type, tax_id, established_year, number_of_employees, website_url, created_at, updated_at, deleted_at
`

// RestoreMerchantBusinessInformation: Restores a soft-deleted business info record
// Purpose: Reactivate a previously trashed record
// Parameters:
//
//	$1: merchant_business_info_id
//
// Returns: The restored business info record
// Business Logic:
//   - Clears deleted_at
//   - Only works for soft-deleted entries
func (q *Queries) RestoreMerchantBusinessInformation(ctx context.Context, merchantBusinessInfoID int32) (*MerchantBusinessInformation, error) {
	row := q.db.QueryRowContext(ctx, restoreMerchantBusinessInformation, merchantBusinessInfoID)
	var i MerchantBusinessInformation
	err := row.Scan(
		&i.MerchantBusinessInfoID,
		&i.MerchantID,
		&i.BusinessType,
		&i.TaxID,
		&i.EstablishedYear,
		&i.NumberOfEmployees,
		&i.WebsiteUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashMerchantBusinessInformation = `-- name: TrashMerchantBusinessInformation :one
UPDATE merchant_business_information
SET deleted_at = CURRENT_TIMESTAMP
WHERE merchant_business_info_id = $1
  AND deleted_at IS NULL
RETURNING merchant_business_info_id, merchant_id, business_type, tax_id, established_year, number_of_employees, website_url, created_at, updated_at, deleted_at
`

// TrashMerchantBusinessInformation: Soft-deletes a business info record
// Purpose: Deactivate business info without removing from DB
// Parameters:
//
//	$1: merchant_business_info_id
//
// Returns: The soft-deleted record
// Business Logic:
//   - Sets deleted_at timestamp
//   - Only affects active records
func (q *Queries) TrashMerchantBusinessInformation(ctx context.Context, merchantBusinessInfoID int32) (*MerchantBusinessInformation, error) {
	row := q.db.QueryRowContext(ctx, trashMerchantBusinessInformation, merchantBusinessInfoID)
	var i MerchantBusinessInformation
	err := row.Scan(
		&i.MerchantBusinessInfoID,
		&i.MerchantID,
		&i.BusinessType,
		&i.TaxID,
		&i.EstablishedYear,
		&i.NumberOfEmployees,
		&i.WebsiteUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateMerchantBusinessInformation = `-- name: UpdateMerchantBusinessInformation :one
UPDATE merchant_business_information
SET
    business_type = $2,
    tax_id = $3,
    established_year = $4,
    number_of_employees = $5,
    website_url = $6,
    updated_at = CURRENT_TIMESTAMP
WHERE
    merchant_business_info_id = $1
    AND deleted_at IS NULL
RETURNING merchant_business_info_id, merchant_id, business_type, tax_id, established_year, number_of_employees, website_url, created_at, updated_at, deleted_at
`

type UpdateMerchantBusinessInformationParams struct {
	MerchantBusinessInfoID int32          `json:"merchant_business_info_id"`
	BusinessType           sql.NullString `json:"business_type"`
	TaxID                  sql.NullString `json:"tax_id"`
	EstablishedYear        sql.NullInt32  `json:"established_year"`
	NumberOfEmployees      sql.NullInt32  `json:"number_of_employees"`
	WebsiteUrl             sql.NullString `json:"website_url"`
}

// UpdateMerchantBusinessInformation: Updates existing business info
// Purpose: Modify business information details
// Parameters:
//
//	$1: merchant_business_info_id
//	$2: business_type
//	$3: tax_id
//	$4: established_year
//	$5: number_of_employees
//	$6: website_url
//
// Returns: The updated business info record
// Business Logic:
//   - Only affects active (non-deleted) records
//   - Automatically updates the updated_at timestamp
func (q *Queries) UpdateMerchantBusinessInformation(ctx context.Context, arg UpdateMerchantBusinessInformationParams) (*MerchantBusinessInformation, error) {
	row := q.db.QueryRowContext(ctx, updateMerchantBusinessInformation,
		arg.MerchantBusinessInfoID,
		arg.BusinessType,
		arg.TaxID,
		arg.EstablishedYear,
		arg.NumberOfEmployees,
		arg.WebsiteUrl,
	)
	var i MerchantBusinessInformation
	err := row.Scan(
		&i.MerchantBusinessInfoID,
		&i.MerchantID,
		&i.BusinessType,
		&i.TaxID,
		&i.EstablishedYear,
		&i.NumberOfEmployees,
		&i.WebsiteUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
