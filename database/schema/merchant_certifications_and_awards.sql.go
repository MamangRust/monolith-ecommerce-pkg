// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: merchant_certifications_and_awards.sql

package db

import (
	"context"
	"database/sql"
)

const createMerchantCertificationOrAward = `-- name: CreateMerchantCertificationOrAward :one
INSERT INTO merchant_certifications_and_awards (
    merchant_id,
    title,
    description,
    issued_by,
    issue_date,
    expiry_date,
    certificate_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING merchant_certification_id, merchant_id, title, description, issued_by, issue_date, expiry_date, certificate_url, created_at, updated_at, deleted_at
`

type CreateMerchantCertificationOrAwardParams struct {
	MerchantID     int32          `json:"merchant_id"`
	Title          string         `json:"title"`
	Description    sql.NullString `json:"description"`
	IssuedBy       sql.NullString `json:"issued_by"`
	IssueDate      sql.NullTime   `json:"issue_date"`
	ExpiryDate     sql.NullTime   `json:"expiry_date"`
	CertificateUrl sql.NullString `json:"certificate_url"`
}

// CreateMerchantCertificationOrAward: Inserts a new certification or award
// Purpose: Register a new certification or award for a merchant
// Parameters:
//
//	$1: merchant_id
//	$2: title
//	$3: description
//	$4: issued_by
//	$5: issue_date
//	$6: expiry_date
//	$7: certificate_url
//
// Returns: The newly created certification record
// Business Logic:
//   - Sets created_at automatically
//   - Requires merchant_id and title
func (q *Queries) CreateMerchantCertificationOrAward(ctx context.Context, arg CreateMerchantCertificationOrAwardParams) (*MerchantCertificationsAndAward, error) {
	row := q.db.QueryRowContext(ctx, createMerchantCertificationOrAward,
		arg.MerchantID,
		arg.Title,
		arg.Description,
		arg.IssuedBy,
		arg.IssueDate,
		arg.ExpiryDate,
		arg.CertificateUrl,
	)
	var i MerchantCertificationsAndAward
	err := row.Scan(
		&i.MerchantCertificationID,
		&i.MerchantID,
		&i.Title,
		&i.Description,
		&i.IssuedBy,
		&i.IssueDate,
		&i.ExpiryDate,
		&i.CertificateUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentMerchantCertificationsAndAwards = `-- name: DeleteAllPermanentMerchantCertificationsAndAwards :exec
DELETE FROM merchant_certifications_and_awards
WHERE deleted_at IS NOT NULL
`

// DeleteAllPermanentMerchantCertificationsAndAwards: Hard-deletes all trashed certifications
// Purpose: Bulk clean-up operation
// Business Logic:
//   - Irreversible delete for all soft-deleted records
//   - Should be restricted to admin-level actions
func (q *Queries) DeleteAllPermanentMerchantCertificationsAndAwards(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentMerchantCertificationsAndAwards)
	return err
}

const deleteMerchantCertificationOrAwardPermanently = `-- name: DeleteMerchantCertificationOrAwardPermanently :exec
DELETE FROM merchant_certifications_and_awards
WHERE merchant_certification_id = $1
  AND deleted_at IS NOT NULL
`

// DeleteMerchantCertificationOrAwardPermanently: Hard-deletes a certification record
// Purpose: Permanently remove a soft-deleted record
// Parameters:
//
//	$1: merchant_certification_id
//
// Business Logic:
//   - Only affects already soft-deleted records
//   - Irreversible action
func (q *Queries) DeleteMerchantCertificationOrAwardPermanently(ctx context.Context, merchantCertificationID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMerchantCertificationOrAwardPermanently, merchantCertificationID)
	return err
}

const getMerchantCertificationOrAward = `-- name: GetMerchantCertificationOrAward :one
SELECT merchant_certification_id, merchant_id, title, description, issued_by, issue_date, expiry_date, certificate_url, created_at, updated_at, deleted_at
FROM merchant_certifications_and_awards
WHERE merchant_certification_id = $1
AND deleted_at IS NULL
`

// GetMerchantCertificationOrAward: Retrieves a single merchant award or certification that is not soft-deleted
// Parameters:
//
//	$1: merchant_certification_id - ID of the award/certification
//
// Business Logic:
//   - Returns the merchant award or certification where deleted_at IS NULL
//
// Returns: A single merchant_certifications_and_awards record
func (q *Queries) GetMerchantCertificationOrAward(ctx context.Context, merchantCertificationID int32) (*MerchantCertificationsAndAward, error) {
	row := q.db.QueryRowContext(ctx, getMerchantCertificationOrAward, merchantCertificationID)
	var i MerchantCertificationsAndAward
	err := row.Scan(
		&i.MerchantCertificationID,
		&i.MerchantID,
		&i.Title,
		&i.Description,
		&i.IssuedBy,
		&i.IssueDate,
		&i.ExpiryDate,
		&i.CertificateUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getMerchantCertificationsAndAwards = `-- name: GetMerchantCertificationsAndAwards :many
SELECT 
    mca.merchant_certification_id, mca.merchant_id, mca.title, mca.description, mca.issued_by, mca.issue_date, mca.expiry_date, mca.certificate_url, mca.created_at, mca.updated_at, mca.deleted_at,
    m.name AS merchant_name,
    COUNT(*) OVER() AS total_count
FROM merchant_certifications_and_awards mca
JOIN merchants m ON mca.merchant_id = m.merchant_id
WHERE LOWER(m.name) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetMerchantCertificationsAndAwardsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetMerchantCertificationsAndAwardsRow struct {
	MerchantCertificationID int32          `json:"merchant_certification_id"`
	MerchantID              int32          `json:"merchant_id"`
	Title                   string         `json:"title"`
	Description             sql.NullString `json:"description"`
	IssuedBy                sql.NullString `json:"issued_by"`
	IssueDate               sql.NullTime   `json:"issue_date"`
	ExpiryDate              sql.NullTime   `json:"expiry_date"`
	CertificateUrl          sql.NullString `json:"certificate_url"`
	CreatedAt               sql.NullTime   `json:"created_at"`
	UpdatedAt               sql.NullTime   `json:"updated_at"`
	DeletedAt               sql.NullTime   `json:"deleted_at"`
	MerchantName            string         `json:"merchant_name"`
	TotalCount              int64          `json:"total_count"`
}

// GetMerchantCertificationsAndAwards: Retrieves all certification records with pagination and optional search
// Parameters:
//
//	$1: search - Keyword to filter merchant_name (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Fetches certifications regardless of merchant status (active or deleted)
//   - Supports case-insensitive partial search by merchant name
//   - Applies pagination using limit and offset
//
// Returns: Certification records matching the search, with total_count
func (q *Queries) GetMerchantCertificationsAndAwards(ctx context.Context, arg GetMerchantCertificationsAndAwardsParams) ([]*GetMerchantCertificationsAndAwardsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMerchantCertificationsAndAwards, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMerchantCertificationsAndAwardsRow
	for rows.Next() {
		var i GetMerchantCertificationsAndAwardsRow
		if err := rows.Scan(
			&i.MerchantCertificationID,
			&i.MerchantID,
			&i.Title,
			&i.Description,
			&i.IssuedBy,
			&i.IssueDate,
			&i.ExpiryDate,
			&i.CertificateUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.MerchantName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantCertificationsAndAwardsActive = `-- name: GetMerchantCertificationsAndAwardsActive :many
SELECT 
    mca.merchant_certification_id, mca.merchant_id, mca.title, mca.description, mca.issued_by, mca.issue_date, mca.expiry_date, mca.certificate_url, mca.created_at, mca.updated_at, mca.deleted_at,
    m.name AS merchant_name,
    COUNT(*) OVER() AS total_count
FROM merchant_certifications_and_awards mca
JOIN merchants m ON mca.merchant_id = m.merchant_id
WHERE m.deleted_at IS NULL
  AND LOWER(m.name) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetMerchantCertificationsAndAwardsActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetMerchantCertificationsAndAwardsActiveRow struct {
	MerchantCertificationID int32          `json:"merchant_certification_id"`
	MerchantID              int32          `json:"merchant_id"`
	Title                   string         `json:"title"`
	Description             sql.NullString `json:"description"`
	IssuedBy                sql.NullString `json:"issued_by"`
	IssueDate               sql.NullTime   `json:"issue_date"`
	ExpiryDate              sql.NullTime   `json:"expiry_date"`
	CertificateUrl          sql.NullString `json:"certificate_url"`
	CreatedAt               sql.NullTime   `json:"created_at"`
	UpdatedAt               sql.NullTime   `json:"updated_at"`
	DeletedAt               sql.NullTime   `json:"deleted_at"`
	MerchantName            string         `json:"merchant_name"`
	TotalCount              int64          `json:"total_count"`
}

// GetMerchantCertificationsAndAwardsActive: Retrieves certifications for active merchants with pagination and optional search
// Parameters:
//
//	$1: search - Keyword to filter merchant_name (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Fetches certifications only for active merchants (deleted_at IS NULL)
//   - Supports case-insensitive partial search by merchant name
//   - Applies pagination using limit and offset
//
// Returns: Active merchant certification records matching the search, with total_count
func (q *Queries) GetMerchantCertificationsAndAwardsActive(ctx context.Context, arg GetMerchantCertificationsAndAwardsActiveParams) ([]*GetMerchantCertificationsAndAwardsActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getMerchantCertificationsAndAwardsActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMerchantCertificationsAndAwardsActiveRow
	for rows.Next() {
		var i GetMerchantCertificationsAndAwardsActiveRow
		if err := rows.Scan(
			&i.MerchantCertificationID,
			&i.MerchantID,
			&i.Title,
			&i.Description,
			&i.IssuedBy,
			&i.IssueDate,
			&i.ExpiryDate,
			&i.CertificateUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.MerchantName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantCertificationsAndAwardsTrashed = `-- name: GetMerchantCertificationsAndAwardsTrashed :many
SELECT 
    mca.merchant_certification_id, mca.merchant_id, mca.title, mca.description, mca.issued_by, mca.issue_date, mca.expiry_date, mca.certificate_url, mca.created_at, mca.updated_at, mca.deleted_at,
    m.name AS merchant_name,
    COUNT(*) OVER() AS total_count
FROM merchant_certifications_and_awards mca
JOIN merchants m ON mca.merchant_id = m.merchant_id
WHERE m.deleted_at IS NOT NULL
  AND LOWER(m.name) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetMerchantCertificationsAndAwardsTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetMerchantCertificationsAndAwardsTrashedRow struct {
	MerchantCertificationID int32          `json:"merchant_certification_id"`
	MerchantID              int32          `json:"merchant_id"`
	Title                   string         `json:"title"`
	Description             sql.NullString `json:"description"`
	IssuedBy                sql.NullString `json:"issued_by"`
	IssueDate               sql.NullTime   `json:"issue_date"`
	ExpiryDate              sql.NullTime   `json:"expiry_date"`
	CertificateUrl          sql.NullString `json:"certificate_url"`
	CreatedAt               sql.NullTime   `json:"created_at"`
	UpdatedAt               sql.NullTime   `json:"updated_at"`
	DeletedAt               sql.NullTime   `json:"deleted_at"`
	MerchantName            string         `json:"merchant_name"`
	TotalCount              int64          `json:"total_count"`
}

// GetMerchantCertificationsAndAwardsTrashed: Retrieves certifications for deleted merchants with pagination and optional search
// Parameters:
//
//	$1: search - Keyword to filter merchant_name (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Fetches certifications only for deleted merchants (deleted_at IS NOT NULL)
//   - Supports case-insensitive partial search by merchant name
//   - Applies pagination using limit and offset
//
// Returns: Trashed merchant certification records matching the search, with total_count
func (q *Queries) GetMerchantCertificationsAndAwardsTrashed(ctx context.Context, arg GetMerchantCertificationsAndAwardsTrashedParams) ([]*GetMerchantCertificationsAndAwardsTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getMerchantCertificationsAndAwardsTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMerchantCertificationsAndAwardsTrashedRow
	for rows.Next() {
		var i GetMerchantCertificationsAndAwardsTrashedRow
		if err := rows.Scan(
			&i.MerchantCertificationID,
			&i.MerchantID,
			&i.Title,
			&i.Description,
			&i.IssuedBy,
			&i.IssueDate,
			&i.ExpiryDate,
			&i.CertificateUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.MerchantName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllMerchantCertificationsAndAwards = `-- name: RestoreAllMerchantCertificationsAndAwards :exec
UPDATE merchant_certifications_and_awards
SET deleted_at = NULL
WHERE deleted_at IS NOT NULL
`

// RestoreAllMerchantCertificationsAndAwards: Restores all soft-deleted certifications
// Purpose: Bulk restore operation
// Business Logic:
//   - Clears deleted_at field from all trashed records
//   - Useful for recovery or admin batch restore
func (q *Queries) RestoreAllMerchantCertificationsAndAwards(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllMerchantCertificationsAndAwards)
	return err
}

const restoreMerchantCertificationOrAward = `-- name: RestoreMerchantCertificationOrAward :one
UPDATE merchant_certifications_and_awards
SET deleted_at = NULL
WHERE merchant_certification_id = $1
  AND deleted_at IS NOT NULL
RETURNING merchant_certification_id, merchant_id, title, description, issued_by, issue_date, expiry_date, certificate_url, created_at, updated_at, deleted_at
`

// RestoreMerchantCertificationOrAward: Restores a soft-deleted certification
// Purpose: Reactivate a previously deleted record
// Parameters:
//
//	$1: merchant_certification_id
//
// Returns: The restored record
// Business Logic:
//   - Clears deleted_at
//   - Only works on previously soft-deleted entries
func (q *Queries) RestoreMerchantCertificationOrAward(ctx context.Context, merchantCertificationID int32) (*MerchantCertificationsAndAward, error) {
	row := q.db.QueryRowContext(ctx, restoreMerchantCertificationOrAward, merchantCertificationID)
	var i MerchantCertificationsAndAward
	err := row.Scan(
		&i.MerchantCertificationID,
		&i.MerchantID,
		&i.Title,
		&i.Description,
		&i.IssuedBy,
		&i.IssueDate,
		&i.ExpiryDate,
		&i.CertificateUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashMerchantCertificationOrAward = `-- name: TrashMerchantCertificationOrAward :one
UPDATE merchant_certifications_and_awards
SET deleted_at = CURRENT_TIMESTAMP
WHERE merchant_certification_id = $1
  AND deleted_at IS NULL
RETURNING merchant_certification_id, merchant_id, title, description, issued_by, issue_date, expiry_date, certificate_url, created_at, updated_at, deleted_at
`

// TrashMerchantCertificationOrAward: Soft-deletes a certification or award
// Purpose: Deactivate a record without permanent deletion
// Parameters:
//
//	$1: merchant_certification_id
//
// Returns: The soft-deleted certification record
// Business Logic:
//   - Sets deleted_at timestamp
//   - Only affects active records
func (q *Queries) TrashMerchantCertificationOrAward(ctx context.Context, merchantCertificationID int32) (*MerchantCertificationsAndAward, error) {
	row := q.db.QueryRowContext(ctx, trashMerchantCertificationOrAward, merchantCertificationID)
	var i MerchantCertificationsAndAward
	err := row.Scan(
		&i.MerchantCertificationID,
		&i.MerchantID,
		&i.Title,
		&i.Description,
		&i.IssuedBy,
		&i.IssueDate,
		&i.ExpiryDate,
		&i.CertificateUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateMerchantCertificationOrAward = `-- name: UpdateMerchantCertificationOrAward :one
UPDATE merchant_certifications_and_awards
SET
    title = $2,
    description = $3,
    issued_by = $4,
    issue_date = $5,
    expiry_date = $6,
    certificate_url = $7,
    updated_at = CURRENT_TIMESTAMP
WHERE
    merchant_certification_id = $1
    AND deleted_at IS NULL
RETURNING merchant_certification_id, merchant_id, title, description, issued_by, issue_date, expiry_date, certificate_url, created_at, updated_at, deleted_at
`

type UpdateMerchantCertificationOrAwardParams struct {
	MerchantCertificationID int32          `json:"merchant_certification_id"`
	Title                   string         `json:"title"`
	Description             sql.NullString `json:"description"`
	IssuedBy                sql.NullString `json:"issued_by"`
	IssueDate               sql.NullTime   `json:"issue_date"`
	ExpiryDate              sql.NullTime   `json:"expiry_date"`
	CertificateUrl          sql.NullString `json:"certificate_url"`
}

// UpdateMerchantCertificationOrAward: Updates an existing certification or award
// Purpose: Modify certification or award details
// Parameters:
//
//	$1: merchant_certification_id
//	$2: title
//	$3: description
//	$4: issued_by
//	$5: issue_date
//	$6: expiry_date
//	$7: certificate_url
//
// Returns: The updated certification record
// Business Logic:
//   - Only affects active (non-deleted) records
//   - Automatically updates the updated_at timestamp
func (q *Queries) UpdateMerchantCertificationOrAward(ctx context.Context, arg UpdateMerchantCertificationOrAwardParams) (*MerchantCertificationsAndAward, error) {
	row := q.db.QueryRowContext(ctx, updateMerchantCertificationOrAward,
		arg.MerchantCertificationID,
		arg.Title,
		arg.Description,
		arg.IssuedBy,
		arg.IssueDate,
		arg.ExpiryDate,
		arg.CertificateUrl,
	)
	var i MerchantCertificationsAndAward
	err := row.Scan(
		&i.MerchantCertificationID,
		&i.MerchantID,
		&i.Title,
		&i.Description,
		&i.IssuedBy,
		&i.IssueDate,
		&i.ExpiryDate,
		&i.CertificateUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
