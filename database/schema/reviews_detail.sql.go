// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reviews_detail.sql

package db

import (
	"context"
	"database/sql"
)

const createReviewDetail = `-- name: CreateReviewDetail :one
INSERT INTO review_details (review_id, type, url, caption)
VALUES ($1, $2, $3, $4)
RETURNING review_detail_id, review_id, type, url, caption, created_at, updated_at, deleted_at
`

type CreateReviewDetailParams struct {
	ReviewID int32          `json:"review_id"`
	Type     string         `json:"type"`
	Url      string         `json:"url"`
	Caption  sql.NullString `json:"caption"`
}

// CreateReviewDetail: Inserts a new review detail
// Parameters:
//
//	$1: review_id - Foreign key to reviews table
//	$2: type - Either 'photo' or 'video'
//	$3: url - URL of the media
//	$4: caption - Optional caption
//
// Returns: The inserted review detail record
func (q *Queries) CreateReviewDetail(ctx context.Context, arg CreateReviewDetailParams) (*ReviewDetail, error) {
	row := q.db.QueryRowContext(ctx, createReviewDetail,
		arg.ReviewID,
		arg.Type,
		arg.Url,
		arg.Caption,
	)
	var i ReviewDetail
	err := row.Scan(
		&i.ReviewDetailID,
		&i.ReviewID,
		&i.Type,
		&i.Url,
		&i.Caption,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentReviewDetails = `-- name: DeleteAllPermanentReviewDetails :exec
DELETE FROM review_details
WHERE deleted_at IS NOT NULL
`

// DeleteAllPermanentReviewDetails: Permanently deletes all trashed review details
// Parameters: None
// Business Logic:
//   - Deletes all records where deleted_at IS NOT NULL
//
// Returns: No return value (exec command)
func (q *Queries) DeleteAllPermanentReviewDetails(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentReviewDetails)
	return err
}

const deletePermanentReviewDetail = `-- name: DeletePermanentReviewDetail :exec
DELETE FROM review_details WHERE review_detail_id = $1
AND deleted_at IS NOT NULL
`

// DeletePermanentReviewDetail: Permanently deletes a soft-deleted review detail
// Parameters:
//
//	$1: review_detail_id - ID of the record to permanently delete
//
// Business Logic:
//   - Only deletes if deleted_at IS NOT NULL
//
// Returns: No return value (exec command)
func (q *Queries) DeletePermanentReviewDetail(ctx context.Context, reviewDetailID int32) error {
	_, err := q.db.ExecContext(ctx, deletePermanentReviewDetail, reviewDetailID)
	return err
}

const getReviewDetail = `-- name: GetReviewDetail :one
SELECT review_detail_id, review_id, type, url, caption, created_at, updated_at, deleted_at
FROM review_details
WHERE review_detail_id = $1
AND deleted_at IS NULL
`

// GetReviewDetail: Retrieves a single review detail that is not soft-deleted
// Parameters:
//
//	$1: review_detail_id - ID of the review detail
//
// Business Logic:
//   - Returns the review detail where deleted_at IS NULL
//
// Returns: A single review_details record
func (q *Queries) GetReviewDetail(ctx context.Context, reviewDetailID int32) (*ReviewDetail, error) {
	row := q.db.QueryRowContext(ctx, getReviewDetail, reviewDetailID)
	var i ReviewDetail
	err := row.Scan(
		&i.ReviewDetailID,
		&i.ReviewID,
		&i.Type,
		&i.Url,
		&i.Caption,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getReviewDetailTrashed = `-- name: GetReviewDetailTrashed :one
SELECT review_detail_id, review_id, type, url, caption, created_at, updated_at, deleted_at
FROM review_details
WHERE review_detail_id = $1
AND deleted_at IS NOT NULL
`

// GetReviewDetailTrashed: Retrieves a single review detail that is not soft-deleted
// Parameters:
//
//	$1: review_detail_id - ID of the review detail
//
// Business Logic:
//   - Returns the review detail where deleted_at IS NULL
//
// Returns: A single review_details record
func (q *Queries) GetReviewDetailTrashed(ctx context.Context, reviewDetailID int32) (*ReviewDetail, error) {
	row := q.db.QueryRowContext(ctx, getReviewDetailTrashed, reviewDetailID)
	var i ReviewDetail
	err := row.Scan(
		&i.ReviewDetailID,
		&i.ReviewID,
		&i.Type,
		&i.Url,
		&i.Caption,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getReviewDetails = `-- name: GetReviewDetails :many
SELECT 
    rd.review_detail_id, rd.review_id, rd.type, rd.url, rd.caption, rd.created_at, rd.updated_at, rd.deleted_at,
    COUNT(*) OVER() AS total_count
FROM review_details rd
WHERE LOWER(COALESCE(caption, '')) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetReviewDetailsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetReviewDetailsRow struct {
	ReviewDetailID int32          `json:"review_detail_id"`
	ReviewID       int32          `json:"review_id"`
	Type           string         `json:"type"`
	Url            string         `json:"url"`
	Caption        sql.NullString `json:"caption"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	TotalCount     int64          `json:"total_count"`
}

// GetReviewDetails: Retrieves all review details (active and trashed)
// Parameters:
//
//	$1: search - Keyword to filter caption (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Returns both active and trashed records
//   - Applies case-insensitive partial search on caption
//   - Supports pagination
//
// Returns: List of review details with total_count metadata
func (q *Queries) GetReviewDetails(ctx context.Context, arg GetReviewDetailsParams) ([]*GetReviewDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getReviewDetails, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetReviewDetailsRow
	for rows.Next() {
		var i GetReviewDetailsRow
		if err := rows.Scan(
			&i.ReviewDetailID,
			&i.ReviewID,
			&i.Type,
			&i.Url,
			&i.Caption,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewDetailsActive = `-- name: GetReviewDetailsActive :many
SELECT 
    rd.review_detail_id, rd.review_id, rd.type, rd.url, rd.caption, rd.created_at, rd.updated_at, rd.deleted_at,
    COUNT(*) OVER() AS total_count
FROM review_details rd
WHERE deleted_at IS NULL
  AND LOWER(COALESCE(caption, '')) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetReviewDetailsActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetReviewDetailsActiveRow struct {
	ReviewDetailID int32          `json:"review_detail_id"`
	ReviewID       int32          `json:"review_id"`
	Type           string         `json:"type"`
	Url            string         `json:"url"`
	Caption        sql.NullString `json:"caption"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	TotalCount     int64          `json:"total_count"`
}

// GetReviewDetailsActive: Retrieves active (non-deleted) review details
// Parameters:
//
//	$1: search - Keyword to filter caption (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Returns only records where deleted_at IS NULL
//   - Applies case-insensitive partial search on caption
//   - Supports pagination
//
// Returns: List of active review details with total_count metadata
func (q *Queries) GetReviewDetailsActive(ctx context.Context, arg GetReviewDetailsActiveParams) ([]*GetReviewDetailsActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getReviewDetailsActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetReviewDetailsActiveRow
	for rows.Next() {
		var i GetReviewDetailsActiveRow
		if err := rows.Scan(
			&i.ReviewDetailID,
			&i.ReviewID,
			&i.Type,
			&i.Url,
			&i.Caption,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewDetailsTrashed = `-- name: GetReviewDetailsTrashed :many
SELECT 
    rd.review_detail_id, rd.review_id, rd.type, rd.url, rd.caption, rd.created_at, rd.updated_at, rd.deleted_at,
    COUNT(*) OVER() AS total_count
FROM review_details rd
WHERE deleted_at IS NOT NULL
  AND LOWER(COALESCE(caption, '')) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetReviewDetailsTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetReviewDetailsTrashedRow struct {
	ReviewDetailID int32          `json:"review_detail_id"`
	ReviewID       int32          `json:"review_id"`
	Type           string         `json:"type"`
	Url            string         `json:"url"`
	Caption        sql.NullString `json:"caption"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	TotalCount     int64          `json:"total_count"`
}

// GetTrashedReviewDetails: Retrieves trashed (soft-deleted) review details
// Parameters:
//
//	$1: search - Keyword to filter caption (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Returns only records where deleted_at IS NOT NULL
//   - Applies case-insensitive partial search on caption
//   - Supports pagination
//
// Returns: List of trashed review details with total_count metadata
func (q *Queries) GetReviewDetailsTrashed(ctx context.Context, arg GetReviewDetailsTrashedParams) ([]*GetReviewDetailsTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getReviewDetailsTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetReviewDetailsTrashedRow
	for rows.Next() {
		var i GetReviewDetailsTrashedRow
		if err := rows.Scan(
			&i.ReviewDetailID,
			&i.ReviewID,
			&i.Type,
			&i.Url,
			&i.Caption,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllReviewDetails = `-- name: RestoreAllReviewDetails :exec
UPDATE review_details
SET deleted_at = NULL
WHERE deleted_at IS NOT NULL
`

// RestoreAllReviewDetails: Restores all soft-deleted review details
// Parameters: None
// Business Logic:
//   - Sets deleted_at to NULL for all trashed records
//
// Returns: No return value (exec command)
func (q *Queries) RestoreAllReviewDetails(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllReviewDetails)
	return err
}

const restoreReviewDetail = `-- name: RestoreReviewDetail :one
UPDATE review_details
SET deleted_at = NULL
WHERE review_detail_id = $1
AND deleted_at IS NOT NULL
RETURNING review_detail_id, review_id, type, url, caption, created_at, updated_at, deleted_at
`

// RestoreReviewDetail: Restores a soft-deleted review detail
// Parameters:
//
//	$1: review_detail_id - ID of the record to restore
//
// Business Logic:
//   - Only restores if deleted_at IS NOT NULL
//
// Returns: The restored review detail
func (q *Queries) RestoreReviewDetail(ctx context.Context, reviewDetailID int32) (*ReviewDetail, error) {
	row := q.db.QueryRowContext(ctx, restoreReviewDetail, reviewDetailID)
	var i ReviewDetail
	err := row.Scan(
		&i.ReviewDetailID,
		&i.ReviewID,
		&i.Type,
		&i.Url,
		&i.Caption,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashReviewDetail = `-- name: TrashReviewDetail :one
UPDATE review_details
SET deleted_at = CURRENT_TIMESTAMP
WHERE review_detail_id = $1
AND deleted_at IS NOT NULL
RETURNING review_detail_id, review_id, type, url, caption, created_at, updated_at, deleted_at
`

// TrashReviewDetail: Soft deletes a review detail
// Parameters:
//
//	$1: review_detail_id - ID of the record to soft delete
//
// Business Logic:
//   - Only applies soft-delete if record is not already trashed
//
// Returns: The soft-deleted review detail
func (q *Queries) TrashReviewDetail(ctx context.Context, reviewDetailID int32) (*ReviewDetail, error) {
	row := q.db.QueryRowContext(ctx, trashReviewDetail, reviewDetailID)
	var i ReviewDetail
	err := row.Scan(
		&i.ReviewDetailID,
		&i.ReviewID,
		&i.Type,
		&i.Url,
		&i.Caption,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateReviewDetail = `-- name: UpdateReviewDetail :one
UPDATE review_details
SET 
    type = $1,
    url = $2,
    caption = $3
WHERE 
    review_detail_id = $4
RETURNING review_detail_id, review_id, type, url, caption, created_at, updated_at, deleted_at
`

type UpdateReviewDetailParams struct {
	Type           string         `json:"type"`
	Url            string         `json:"url"`
	Caption        sql.NullString `json:"caption"`
	ReviewDetailID int32          `json:"review_detail_id"`
}

// UpdateReviewDetail: Updates an existing review detail
// Parameters:
//
//	$1: type - New media type
//	$2: url - New media URL
//	$3: caption - Updated caption
//	$4: review_detail_id - Target record to update
//
// Returns: The updated review detail record
func (q *Queries) UpdateReviewDetail(ctx context.Context, arg UpdateReviewDetailParams) (*ReviewDetail, error) {
	row := q.db.QueryRowContext(ctx, updateReviewDetail,
		arg.Type,
		arg.Url,
		arg.Caption,
		arg.ReviewDetailID,
	)
	var i ReviewDetail
	err := row.Scan(
		&i.ReviewDetailID,
		&i.ReviewID,
		&i.Type,
		&i.Url,
		&i.Caption,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
