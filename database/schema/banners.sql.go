// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: banners.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createBanner = `-- name: CreateBanner :one
INSERT INTO banners (
    name,
    start_date,
    end_date,
    start_time,
    end_time,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING banner_id, name, start_date, end_date, start_time, end_time, is_active, created_at, updated_at, deleted_at
`

type CreateBannerParams struct {
	Name      string       `json:"name"`
	StartDate time.Time    `json:"start_date"`
	EndDate   time.Time    `json:"end_date"`
	StartTime time.Time    `json:"start_time"`
	EndTime   time.Time    `json:"end_time"`
	IsActive  sql.NullBool `json:"is_active"`
}

// CreateBanner: Inserts a new banner
// Parameters:
//
//	$1: name
//	$2: start_date
//	$3: end_date
//	$4: start_time
//	$5: end_time
//	$6: is_active
//
// Returns: The newly created banner
func (q *Queries) CreateBanner(ctx context.Context, arg CreateBannerParams) (*Banner, error) {
	row := q.db.QueryRowContext(ctx, createBanner,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
		arg.StartTime,
		arg.EndTime,
		arg.IsActive,
	)
	var i Banner
	err := row.Scan(
		&i.BannerID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentBanners = `-- name: DeleteAllPermanentBanners :exec
DELETE FROM banners
WHERE deleted_at IS NOT NULL
`

// DeleteAllPermanentBanners: Permanently delete all trashed banners
func (q *Queries) DeleteAllPermanentBanners(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentBanners)
	return err
}

const deleteBannerPermanently = `-- name: DeleteBannerPermanently :exec
DELETE FROM banners
WHERE banner_id = $1
  AND deleted_at IS NOT NULL
`

// DeleteBannerPermanently: Permanently delete a single trashed banner
// Parameters:
//
//	$1: banner_id
func (q *Queries) DeleteBannerPermanently(ctx context.Context, bannerID int32) error {
	_, err := q.db.ExecContext(ctx, deleteBannerPermanently, bannerID)
	return err
}

const getBanner = `-- name: GetBanner :one
SELECT banner_id, name, start_date, end_date, start_time, end_time, is_active, created_at, updated_at, deleted_at
FROM banners
WHERE banner_id = $1
AND deleted_at IS NULL
`

// GetBanner: Retrieves a single banner that is not soft-deleted
// Parameters:
//
//	$1: banner_id - ID of the banner
//
// Business Logic:
//   - Returns the banner where deleted_at IS NULL
//
// Returns: A single banners record
func (q *Queries) GetBanner(ctx context.Context, bannerID int32) (*Banner, error) {
	row := q.db.QueryRowContext(ctx, getBanner, bannerID)
	var i Banner
	err := row.Scan(
		&i.BannerID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getBanners = `-- name: GetBanners :many
SELECT 
    b.banner_id, b.name, b.start_date, b.end_date, b.start_time, b.end_time, b.is_active, b.created_at, b.updated_at, b.deleted_at,
    COUNT(*) OVER() AS total_count
FROM banners b
WHERE LOWER(name) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetBannersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetBannersRow struct {
	BannerID   int32        `json:"banner_id"`
	Name       string       `json:"name"`
	StartDate  time.Time    `json:"start_date"`
	EndDate    time.Time    `json:"end_date"`
	StartTime  time.Time    `json:"start_time"`
	EndTime    time.Time    `json:"end_time"`
	IsActive   sql.NullBool `json:"is_active"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// GetBanners: Retrieves all banners (active and trashed) with optional search and pagination
// Parameters:
//
//	$1: search - Keyword to filter banner name (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Returns all banners regardless of soft-delete status
//   - Applies case-insensitive partial match on banner name
//   - Supports pagination
//
// Returns: List of all banners with total_count metadata
func (q *Queries) GetBanners(ctx context.Context, arg GetBannersParams) ([]*GetBannersRow, error) {
	rows, err := q.db.QueryContext(ctx, getBanners, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBannersRow
	for rows.Next() {
		var i GetBannersRow
		if err := rows.Scan(
			&i.BannerID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.StartTime,
			&i.EndTime,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersActive = `-- name: GetBannersActive :many
SELECT 
    b.banner_id, b.name, b.start_date, b.end_date, b.start_time, b.end_time, b.is_active, b.created_at, b.updated_at, b.deleted_at,
    COUNT(*) OVER() AS total_count
FROM banners b
WHERE deleted_at IS NULL
  AND LOWER(name) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetBannersActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetBannersActiveRow struct {
	BannerID   int32        `json:"banner_id"`
	Name       string       `json:"name"`
	StartDate  time.Time    `json:"start_date"`
	EndDate    time.Time    `json:"end_date"`
	StartTime  time.Time    `json:"start_time"`
	EndTime    time.Time    `json:"end_time"`
	IsActive   sql.NullBool `json:"is_active"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// GetBannersActive: Retrieves active banners (not soft-deleted)
// Parameters:
//
//	$1: search - Keyword to filter banner name (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Returns banners where deleted_at IS NULL
//   - Applies case-insensitive partial match on banner name
//   - Supports pagination
//
// Returns: List of active banners with total_count metadata
func (q *Queries) GetBannersActive(ctx context.Context, arg GetBannersActiveParams) ([]*GetBannersActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getBannersActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBannersActiveRow
	for rows.Next() {
		var i GetBannersActiveRow
		if err := rows.Scan(
			&i.BannerID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.StartTime,
			&i.EndTime,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersTrashed = `-- name: GetBannersTrashed :many
SELECT 
    b.banner_id, b.name, b.start_date, b.end_date, b.start_time, b.end_time, b.is_active, b.created_at, b.updated_at, b.deleted_at,
    COUNT(*) OVER() AS total_count
FROM banners b
WHERE deleted_at IS NOT NULL
  AND LOWER(name) LIKE LOWER(CONCAT('%', $1::text, '%'))
LIMIT $2 OFFSET $3
`

type GetBannersTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetBannersTrashedRow struct {
	BannerID   int32        `json:"banner_id"`
	Name       string       `json:"name"`
	StartDate  time.Time    `json:"start_date"`
	EndDate    time.Time    `json:"end_date"`
	StartTime  time.Time    `json:"start_time"`
	EndTime    time.Time    `json:"end_time"`
	IsActive   sql.NullBool `json:"is_active"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// GetTrashedBanners: Retrieves soft-deleted (trashed) banners
// Parameters:
//
//	$1: search - Keyword to filter banner name (case-insensitive, partial match)
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Business Logic:
//   - Returns banners where deleted_at IS NOT NULL
//   - Applies case-insensitive partial match on banner name
//   - Supports pagination
//
// Returns: List of trashed banners with total_count metadata
func (q *Queries) GetBannersTrashed(ctx context.Context, arg GetBannersTrashedParams) ([]*GetBannersTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getBannersTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBannersTrashedRow
	for rows.Next() {
		var i GetBannersTrashedRow
		if err := rows.Scan(
			&i.BannerID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.StartTime,
			&i.EndTime,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllBanners = `-- name: RestoreAllBanners :exec
UPDATE banners
SET deleted_at = NULL
WHERE deleted_at IS NOT NULL
`

// RestoreAllBanners: Restore all trashed banners
func (q *Queries) RestoreAllBanners(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllBanners)
	return err
}

const restoreBanner = `-- name: RestoreBanner :one
UPDATE banners
SET deleted_at = NULL
WHERE banner_id = $1
  AND deleted_at IS NOT NULL
RETURNING banner_id, name, start_date, end_date, start_time, end_time, is_active, created_at, updated_at, deleted_at
`

// RestoreBanner: Restores a soft-deleted banner
// Parameters:
//
//	$1: banner_id
//
// Returns: The restored banner
func (q *Queries) RestoreBanner(ctx context.Context, bannerID int32) (*Banner, error) {
	row := q.db.QueryRowContext(ctx, restoreBanner, bannerID)
	var i Banner
	err := row.Scan(
		&i.BannerID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashBanner = `-- name: TrashBanner :one
UPDATE banners
SET deleted_at = CURRENT_TIMESTAMP
WHERE banner_id = $1
  AND deleted_at IS NULL
RETURNING banner_id, name, start_date, end_date, start_time, end_time, is_active, created_at, updated_at, deleted_at
`

// TrashBanner: Soft deletes a banner
// Parameters:
//
//	$1: banner_id
//
// Returns: The trashed banner
func (q *Queries) TrashBanner(ctx context.Context, bannerID int32) (*Banner, error) {
	row := q.db.QueryRowContext(ctx, trashBanner, bannerID)
	var i Banner
	err := row.Scan(
		&i.BannerID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateBanner = `-- name: UpdateBanner :one
UPDATE banners
SET
    name = $2,
    start_date = $3,
    end_date = $4,
    start_time = $5,
    end_time = $6,
    is_active = $7,
    updated_at = CURRENT_TIMESTAMP
WHERE banner_id = $1
  AND deleted_at IS NULL
RETURNING banner_id, name, start_date, end_date, start_time, end_time, is_active, created_at, updated_at, deleted_at
`

type UpdateBannerParams struct {
	BannerID  int32        `json:"banner_id"`
	Name      string       `json:"name"`
	StartDate time.Time    `json:"start_date"`
	EndDate   time.Time    `json:"end_date"`
	StartTime time.Time    `json:"start_time"`
	EndTime   time.Time    `json:"end_time"`
	IsActive  sql.NullBool `json:"is_active"`
}

// UpdateBanner: Updates an existing banner
// Parameters:
//
//	$1: banner_id
//	$2: name
//	$3: start_date
//	$4: end_date
//	$5: start_time
//	$6: end_time
//	$7: is_active
//
// Returns: The updated banner
func (q *Queries) UpdateBanner(ctx context.Context, arg UpdateBannerParams) (*Banner, error) {
	row := q.db.QueryRowContext(ctx, updateBanner,
		arg.BannerID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
		arg.StartTime,
		arg.EndTime,
		arg.IsActive,
	)
	var i Banner
	err := row.Scan(
		&i.BannerID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
